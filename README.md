# AI_PROJECT1

1. INTRODUCTION
TSP(Traveling Salesperson Problem)문제란, 특정 도시를 출발하여 다른 도시들은 한번씩만 들린 후, 다시 출발한 곳으로 돌아오는 경로를 찾는 문제이다.
본 프로젝트는 TSP 문제를 최적화하는 총 3 가지 방법을 python 으로 구현해 성능 및 결과를 분석하는 것을 목적으로 한다. 첫번째 방법은 해를 일정 시간 동안 무작위로 생성해서 좋은 것을 선택하는 방법인 완전 무작위 탐색을 이용하는 것, 두 번째 방법은 유전 알고리즘만을 이용하는 것, 세번째 방법은 제안된 탐색 기법이다. 순차적으로 각 방법의 이론과 구현 방법, 시각화 자료를 이용한 실험 결과 및 분석, 최종 결론을 내리겠다.
2 MAIN STRUCTURE
본 프로젝트는 다음과 같이, 총 4 가지의 내용으로 구성된다. 완전 무작위 탐색을 이용한 TSP 최적의 해 구하기, 유전 알고리즘만을 이용한 TSP 최적의 해 구하기, 제안된 알고리즘 방식으로 TSP 최적의 해 구하기, 결론으로 구성했다.
1. 완전무작위탐색을이용한TSP최적의해구하기 A. 구현 아이디어
완전 무작위 탐색이란, 모든 경우의 수를 전부 찾아서 최적 해를 찾는 알고리즘이다. 무작위로 1000 개의 경로 배열을 만들고, 그 경로를 따라가는 함수를 만드러 완전 무작위 탐색을 하는 코드를 구현했다. 또한, 현재까지의 최고 기록(최단 거리)를 알기 위해, 현재까지의 최고 기록보다 낮은 비용이 나오면 최고 기록으로 갱신하게끔 하고, 도시 좌표와 최단 경로를 시각화했다.
B. 실행결과
코드 실행 결과, 0 번째 탐색했을 때의 최소 경로는 44972 이었고, 100 번째 탐색했을 때의 최소 경로는 42450, 1000 번째 탐색했을 때의 최소 경로는 42170, 10000 번째 탐색했을 때의 최소 경로는 41877 이었다. 100000 번째 탐색했을 때, 최소 경로는 41376 으로 나왔다. 따라서, TSP 문제를 해결하는 직관적이고 간단한 방법 중 하나이지만, 시간복잡도가 O(n!)으로 문제의 규모가 커질수록 계산 시간이
1
  
기하급수적으로 늘어나기에 성능이 좋지 않다. 또한, 최단 거리가 4 만대에서 감소하지 않고 수렴하는 듯한 양상을 보이며, 최적의 해를 찾는 것 또한 효과가 좋지 않았다.
다음은 완전 무작위 탐색으로 TSP 문제의 최적 해를 구한 것을 시각화한 그림이다. 도시들의 x 좌표, y 좌표를 scatter plot 으로 시각화하고, brute-force 를 통해 구한 최단 경로를 따라 도시들을 연결한 그림이다.
도시들의 위치가 무작위로 배치되어 있고, 최단 경로는 매우 복잡한 패턴을 가진 것을 확인할 수 있다.
2. 유전 알고리즘만 이용해 TSP 최적의 해 구하기 A. 유전 알고리즘이란?
2
 
유전 알고리즘이란, 생물체가 환경에 적응하면서 진화해나가는 모습을 모방해 최적해를 찾아내는 검색 방법이다. 이론적으로 전역 최적점을 찾을 수 있으며, 수학적으로 명확하게 정의되지 않은 문제에도 적용할 수 있기에, 매우 유용하게 이용된다.
유전 알고리즘은 초기의 개체를 생성하고, 이후 세대를 거칠 때마다 각 해의 적합도를 평가하고, 이를 기반으로 선택, 교차, 돌연변이 등의 연산 과정을 거쳐, 데이터를 최적화시킨다. 이와 같은 과정은 다음과 같이 정리할 수 있다.
1. 초기, 염색체(경로)를 생성해, 적합성을 평가
2. 선택연산을통해현재세대에서다음세대로전해지는해들을선택
3. 교차연산을통해,부모해의유전자들을서로교차시켜서자식해생성
4. 변이 연산을 통해, 돌연변이 유전자를 고려해, 유전적 다양성 확보
유전적 다양성을 확보하지 않으면, 유전 알고리즘이 이전 세대의 최적해에서 벗어나지 못하고, 지역 최적해에 갇힐 가능성이 있으니, 적절한 돌연변이 확률을 결정하는 것이 중요
5. 각 염색체의 적합성을 판단
6. 적합하지 않으면, 2 ~ 5 과정을 반복, 적합하면 종료한다.
본 프로젝트에서는 이와 같은 유전자 알고리즘을 이용해 TSP 문제의 최적의 해를 구하고자 하였다.
B. 유전 알고리즘의 연산 i. 선택연산
선택연산이란, 교차에 쓰이는 두 개의 부모 해를 고르기 위한 연산이다. 선택 연산의 종류로는 대표적으로 Roulette wheel selection, Tournament selection 이 있다. 이 선택 연산은 우수한 해가 선택될 확률이 높여야 한다.
Roulette wheel selection 이란, 적합도가 높을수록 부모 해로 선택될 확률이 높아지는 방식이다. 즉, 높은 적합도의 개체가 선택될 확률은 높으나, 개체의 적합도가 낮은 경우에는 선택될 확률이 낮으므로, 다양성을 유지하기 어렵다. 반면, Tournament selection 이란, 염색체를 임의의 개수로 선택해서 tournament 방식으로 부모해를 선택하는 방식이다.
3

본 프로젝트에서는 총 두 가지의 선택 연산을 시도했다. 첫 번째 선택연산은 Roulette wheel selection 이었다. roulette wheel 선택 연산을 구현해 개체의 적합도에 비례하도록 부모 세대를 뽑도록 해, 더 나은 최적의 해(최단 경로)를 찾고자 하였다. 그러나, 실제 출력 결과,
0 세대에서의 최단 경로는 45200, 100 세대에서의 최단경로 44869, 500 세대에서의 최단 경로는 44722 인 것을 볼 수 있었다. 따라서, 최적 해에 대한 탐색 효율이 완전 무작위 탐색과 비교했을 때 두드러지는 장점을 발견할 수 없어 두 번째 시도를 진행했다.
두 번째 선택연산은 population 리스트를 fitness 순으로 내림차순으로 정렬한 뒤, 가장 높은 적합도를 가진 2 개의 도시를 선택하는 것이었다. 이 방법은 유전적 다양성을 보장하기는 어려우나, 가장 적합한 개체를 선택하기에 최적의 경로를 찾는 장점이 있어 선택하게 되었다. 실제 출력 결과, 0 세대에서의 최단 경로 41844, 50 세대에서의 최단 경로 34253,
100 세대에서의 최단 경로 29624 인 것을 확인할 수 있었다.
ii. 교차연산
교차 연산이란 부모 해의 유전자들을 서로 교차시켜 자식해를 생성하는 유전 알고리즘의 대표적인 연산이다. 교차 연산은 다양한 종류가 있는데, 대표적인 교차 연산으로는 one point crossover, multi-point crossover, order crossover, partially matched crossover 연산이 있다.
본 프로젝트에서는 one point crossover 교차 연산을 사용했다. 이 때, one point crossover 연산이란, 두 부모 염색체의 한 지점을 선택한 뒤 해당 지점을 기준으로 부모 염색체의 일부를 교환하는 방식이다. 일점 교차 연산은 구현이 간단하고 이해하기 쉽지만, 교차 지점이 랜덤하게 선택되기에 유전자의 일부가 중복될 수 있다. 따라서 우리 코드는 중복된 유전자가 생성되지 않도록, 각 부모 염색체에서 선택된 교차 지점 이후의 유전자를 중복을 피해서 삭제했다. 그 후, 남은 유전자를 서로 교차해 새로운 자손 염색체를 생성했다.
iii. 변이연산
변이 연산은 돌연변이 유전자를 생성해, 유전적 다양성을 확보하는 연산이다. 이때 돌연변이 확률의 값을 잘 설정하는 것이 중요한데, 해당 확률이 너무 크면, 무작위
4

탐색과의 차별을 둘 수 없고, 적은 값의 변화는 지역 최적해에 갇힐 가능성이 높아, 적절한 mutation 비율을 설정하는 것이 중요하다.
변이 연산의 종류는 다양하게 있는데, 두 개의 유전자 값을 교환하는 방식의 swap mutation, 선택된 구간 내의 유전자 값을 무작위로 섞는 방식의 scramble mutation, 선택된 구간 내의 한 유전자 값을 다른 위치에 삽입하는 방식의 insertion mutation, 두 개의 선택된 유전자를 상호 교환해, 선택된 부모 개체의 유전자 정보를 무작위로 변형해 새로운 개체를 생성하는 mutual swap 연산이 그것들이다.
본 프로젝트는 mutual swap 연산을 사용한다. Mutual swap 연산은 유전적 다양성을 유지해, 교배 과정에서 지역 최적해에 빠지지 않게 하도록 하는 장점을 가진다. 이는 가장 최적의 도시 2 개를 선택하게 하는 선택연산의 영향으로 지역 최적해에 빠지는 가능성을 줄이기 위해 고려한 것이다.
3. 제안된 알고리즘 방식
본 프로젝트에서는 dfs 트리 탐색 구조와 총 2 가지의 방식을 적용했다. dfs 트리 탐색 구조는 초기 상태일 경우에는 유전 알고리즘에서 초기 해를 설정하기 위해 3 개로 군집화된 군집들을 대상으로 dfs 알고리즘을 사용했다. 그 결과, 찾은 최소 경로를 초기 염색체로 설정했다.
2 가지 제안 방식은 다음과 같다. 첫 번째는 clustering 의 활용이고, 두 번째는 가변적 POPULATION_SIZE 적용이다. 실제 결과를 출력하고, 유전 알고리즘을 이용해 TSP 문제를 풀 때, 핵심적인 연산자 이외의 값들의 영향과 결과를 그래프로 나타내 분석해 설명하겠다.
A. MUTATION_RATE
5

               위 그래프에서도 볼 수 있듯이, 총 4 가지의 MUTATION_RATE 을 설정해, MUTATION_RATE 값에 따른, 각각의 최소 거리와 시간(성능)을 관찰했다. 위 그래프의 x 축은 세대, 좌측의 y 축은 length, 우측의 y 축은 시간(sec)이다. 돌연변이 확률이 0.01, 0.005, 0.001, 0.0005 일 때의 차이가 거의 없어, 결과적으로 돌연변이 확률은 적합도(최소 거리)와 시간(성능)에 큰 영향을 끼치지 않는다는 사실을 알 수 있었다. 이에 본 프로젝트에서는 적합도와 성능에 유의미한 영향을 끼치지 못했기에, MUTATION_RATE 를 0.001 의 임의의 값으로 설정했다.
B. Clustering
clustering 이란 unsupervised learning 의 일종으로, 비슷한 특성을 가진 데이터들을 그룹으로 나누는 알고리즘이다. 본 프로젝트에서는 대표적인 clustering 중 하나인 k-means clustering 방식(입력값으로 cluster 개수와 초기값을 입력받아, 각 데이터의 그룹을 할당해나가는 알고리즘)을 활용해, 3 개의 군집으로 도시들을 분류한 후, 각 군집에서 랜덤으로 하나씩 도시를 선택해 초기
6

세대를 생성한 뒤, 유전 알고리즘의 선택, 교차, 돌연변이 연산을 거쳐 가장 최적의 경로를 출력하는 것을 목표로 했다. 이를 위해 3 군집으로 도시를 분류한 k-means clustering 를 시각화한 결과와 clustering 과 유전 알고리즘을 이용해 TSP 최적의 해를 구할 때의 최소 거리와 시간(성능)에 대한 결과를 살펴보겠다.
왼쪽 그림은 k-means clustering 을 시각화한 결과이다. 입력값으로 cluster 개수는 3, 초기값은 k-means++ 알고리즘을 사용해 초기 중심점을 설정했다. 오른쪽 그래프는 clustering 과 유전 알고리즘(앞선 2 번 알고리즘에서 제안했던)을 이용해 TSP 최적의 해를 구할 때의 최소 거리와 시간(성능)에 대한 결과를 그래프로 나타낸 것이다. x 축은 세대, 좌측 y 축은 length, 우측 y 축은 sec 를 나타낸다. 그래프를 분석한 결과, 최소 거리와 시간 성능은 반비례 관계에 있음을 알 수 있었다.
따라서, 본 프로젝트에서는 clustering 이외에도 population_size 변수에 따른 최소 거리와 성능을 분석했다.
C. 가변적 POPULATION_SIZE 적용
유전 알고리즘의 선택 연산, 교차 연산, 돌연변이 연산 방식 이외에도 다양한 변수의 값을 조정해, 최소 거리와 시간 성능에 영향을 줄 수 있다. 본 프로젝트는 돌연변이 확률 값인 MUTATION_RATE 변수, 개체 집단의 크기인 POPULATION 변수를 각각 실험군으로 설정해, 최소 거리와 시간 성능의 영향을 분석해보겠다.
i. POPULATION SIZE 단순 비교
7
         
         돌연변이 확률을 0.001 로 동일하게 설정하고, population size 가 700 과(왼쪽 그래프) 300(오른쪽 그래프)으로 조절하여 실험을 진행했다. 위 그래프의 x 축은 세대, 좌측 y 측은 length, 우측 y 축은 시간(sec)이다. 결과, population size 가 클수록, 최소 거리가 늘어나는 것에 비해, 시간 성능이 월등히 좋아진 것을 확인할 수 있었다.
ii. Population 값에 따른 Fitness 값 변화량 그래프
 위 내용은 population 값을 다양하게 변경하며, length 값에서의 순간변화량에 대한 그래프이다.(x 축 : length, y 축 : 순간변화량) 그래프 분석 결과, population size 가 작을 때 초기에는 순간 변화량이 높으나 일정 length 이후에는 값이 음수로 내려가는 경향이 있었다. 반면, population size 가 클 때에는 순간 변화량이 낮지만, 그래프의 절댓값 기울기가 작아
length 값이 꾸준히 감소했다.
8

따라서, 본 프로젝트에서는 length 값에 따라 population 값을 가변적으로 조정하여 알고리즘의 성능을 개선하기 위해 제안한 두 가지 함수 VAR_v1 과 VAR_v2 중, VAR_V1 의 세 가지 문제점을 보완한 VAR_V2 함수를 제안했다. 이 방법은 length 값이 높을 때는 작은 population 값을 사용하여 빠르게 length 값을 감소시키고, length 값이 작을 때는 높은 population 값을 사용해 min_length 값을 갱신하게끔 했다. 시간적 성능에 있어 손해가 있을 수 있지만, min_length 값을 갱신시킨다는 이점이 있다.
VAR_V1 은 다음의 함수이다. population_size(p) = (200000 / min_length)^4 * 0.001.
min_length 가 20000 일 때는 그래프에서 가장 높은 값인 p = 10, min_length 가 6000 일 때는 p =
1000 에서도 값이 음수로 내려갔기에 함수값이 1000 이상이 되도록 설정했다. 그러나 위
함수에는 세 가지 문제점이 있어 이 문제점들을 보완한 VAR_v2 함수를 제안했다. 세 가지
문제점들은 다음과 같다. 첫 번째는 min_length 가 6000 이하에서는 p = 1000 일 때의
순간변화량보다 작아지는 문제, 두 번째는 min_length 가 4000 에 근접할수록 p 값이 급격히
증가해 시간 성능이 크게 떨어지는 문제, 세 번째는 min_length 값이 8000~15000 에서 p 값이
예상보다 높아 시간 성능이 저하되는 문제이다. VAR_V2 은 다음의 함수이다. population_size = (210000 / min_length)^3.5 * 0.003
그 결과, VAR_V2 는 VAR_v1 에 비해 성능이 개선된 것을 확인할 수 있었다. VAR_v2 를 사용하면 min_length 값이 4450 값에 도달할 때까지, VAR_v1 에 비해 약 11.2%의 성능 향상을 볼 수 있었다.
         9

4. 결론
결론적으로 본 프로젝트에서는 도시들은 dfs 트리 탐색 구조를 이용하고, clustering 을 통해 3 가지 그룹들로 군집화하고, population size 를 가변적으로 변화시켜 시간 성능과 최소 거리 모두를 향상시키는 알고리즘을 제안했다. 이때 mutation rate 는 적합도와 성능에 유의미한 영향을 끼치지 못했기에 임의의 값으로 0.001 로 설정했다. clustering 할 때는 cluster 개수를 3 개, k-means++알고리즘을 사용해 초기 중심점을 선택했다. 우리 연구에서는 실험결과를 바탕으로, length 값이 클 때는 작은 population 값을, length 값이 작을 때는 높은 population 값을 사용하여 최적의 길이와 시간 성능을 얻을 수 있었다. 따라서 population 값의 초기값을 10 으로 설정하고, VAR_V2 함수를 활용하여 population 값을 가변적으로 조정했다.
선택연산은 Roulette wheel selection 연산에서는 최적 해를 찾는 데 완전 무작위 탐색과 비교하여 탐색 효율의 차이를 확인하기 어려워, population 을 fitness 함수를 기준으로 내림 차순 정렬한 뒤, 가장 적합도가 높은 도시 2 개를 선택하도록 했다.
10
 
교차연산은 one point crossover 방식을 선택했다. 일점 교차는 구현이 간단하지만, 교차 지점이 랜덤하게 선택되기에 유전자의 일부가 중복될 위험이 있어, 유전자 중복 생성을 방지하기 위해 각 부모 염색체에서 선택된 교차 지점 이후의 유전자를 삭제했다.
변이연산은 mutual swap 을 선택했다. 이는 가장 최적의 도시 2 개를 선택하는 선택연산의 영향으로 지역 최적해에 빠지는 가능성을 방지하고자 했다.
마지막으로, brute-force 방식과 유전 알고리즘만 적용한 방식, 유전 알고리즘과 clustering, variable population size 를 함께 적용한 방식 간의 성능 차이를 비교해보겠다.
1 시간동안 알고리즘을 실행했을 때, 세 알고리즘이 도출한 최단 경로값은 다음과 같다. Brute force : 41285, 유전 알고리즘 : 7362, 제안된 알고리즘 : 4722.12 이다. 또한, 제안된 알고리즘으로 8시간을 실행한 결과, 최단 경로값은 4178.11이 나왔다.
